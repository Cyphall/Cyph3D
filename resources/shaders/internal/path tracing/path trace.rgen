#version 460 core
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_scalar_block_layout : require

struct HitPayload
{
	uint randomOffset;
	vec3 light;
	vec3 contribution;
	bool hit;
	vec3 rayPosition;
	vec3 rayDirection;
};

layout(set = 1, binding = 0) uniform accelerationStructureEXT u_topLevelAS;
layout(set = 1, binding = 1, rgba32f) uniform image2D u_color;

layout(shaderRecordEXT) buffer uniforms
{
	vec3 u_position;
	vec3 u_rayTL;
	vec3 u_rayTR;
	vec3 u_rayBL;
	vec3 u_rayBR;
};

layout(push_constant) uniform constants
{
	uint u_batchIndex;
	uint u_sampleCount;
	bool u_resetAccumulation;
};

layout(location = 0) rayPayloadEXT HitPayload hitPayload;

const int MAX_DEPTH = 4;

vec4 getRandom()
{
	uvec4 v = uvec4(uvec2(gl_LaunchIDEXT.xy), u_batchIndex, hitPayload.randomOffset++);
	
	v = v * 1664525u + 1013904223u;
	v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;
	v ^= v >> 16u;
	v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;
	
	return clamp(v * (1.0 / float(0xffffffffu)), 0.0, 1.0);
}

void main()
{
	hitPayload.randomOffset = 0;
	hitPayload.light = vec3(0);
	
	for (int s = 0; s < u_sampleCount; s++)
	{
		hitPayload.contribution = vec3(1);
		hitPayload.rayPosition = u_position;
		
		vec2 PS_rayPos = vec2(gl_LaunchIDEXT.xy) + 0.5 + (getRandom().xy - 0.5);
		vec2 UVS_rayPos = PS_rayPos / vec2(gl_LaunchSizeEXT.xy);
		
		vec3 topRayDir = mix(u_rayTL, u_rayTR, UVS_rayPos.x);
		vec3 bottomRayDir = mix(u_rayBL, u_rayBR, UVS_rayPos.x);
		hitPayload.rayDirection = normalize(mix(topRayDir, bottomRayDir, UVS_rayPos.y));
		
		for (int d = 0; d < MAX_DEPTH; d++)
		{
			traceRayEXT(
				u_topLevelAS,            // acceleration structure
				gl_RayFlagsOpaqueEXT,    // rayFlags
				0xFF,                    // cullMask
				0,                       // sbtRecordOffset (ray type)
				1,                       // sbtRecordStride (number of ray types
				0,                       // missIndex
				hitPayload.rayPosition,  // ray origin
				0.0,                     // ray min range
				hitPayload.rayDirection, // ray direction
				10000.0,                 // ray max range
				0                        // payload (location = 0)
			);
			
			if (!hitPayload.hit)
			{
				break;
			}
		}
	}
	
	vec3 totalLight = u_resetAccumulation ? vec3(0) : imageLoad(u_color, ivec2(gl_LaunchIDEXT.xy)).rgb;
	
	totalLight += hitPayload.light / u_sampleCount; // we do one division here to reduce precision error causing color banding with very high numbers of samples
	
	imageStore(u_color, ivec2(gl_LaunchIDEXT.xy), vec4(totalLight, 1.0));
}

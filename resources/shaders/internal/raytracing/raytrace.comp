#version 460 core
#extension GL_ARB_bindless_texture : enable

/* ------ consts ------ */
const float PI = 3.14159265359;
const float TWO_PI = PI*2;
const float SQRT_2 = 1.41421356237;

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Camera
{
	vec3 position;
	float padding0;
	vec3 rayTL;
	float padding1;
	vec3 rayTR;
	float padding2;
	vec3 rayBL;
	float padding3;
	vec3 rayBR;
	float padding4;
};

struct Material
{
	layout(bindless_sampler) sampler2D albedo;
	layout(bindless_sampler) sampler2D normal;
	layout(bindless_sampler) sampler2D roughness;
	layout(bindless_sampler) sampler2D metallic;
	layout(bindless_sampler) sampler2D displacement;
	layout(bindless_sampler) sampler2D emissive;
};

struct HitInfo
{
	bool anyHit;
	float t;
	vec3 impact;
	vec3 normal;
	Material material;
	vec2 uv;
	int objectIndex;
};

struct Transform
{
	mat4 localToWorld;
	mat4 worldToLocal;
	mat4 localToWorldDirection;
	mat4 worldToLocalDirection;
	mat4 localToWorldNormal;
};

struct Sphere
{
	Material material;
	Transform transform;
	int objectIndex;
	float padding0;
	float padding1;
	float padding2;
};

struct Plane
{
	Material material;
	Transform transform;
	bool infinite;
	int objectIndex;
	float padding0;
	float padding1;
};

struct DirectionalLight
{
	vec3 fragToLightDirection;
	float angularDiameter;
	vec3 color;
	float intensity;
};

struct PointLight
{
	vec3 position;
	float size;
	vec3 color;
	float intensity;
};

struct Mesh
{
	Material material;
	Transform transform;
	int objectIndex;
	int vertexOffset;
	int indexOffset;
	int indexCount;
};

struct Vertex
{
	float position_x;
	float position_y;
	float position_z;
	float u;
	float v;
	float normal_x;
	float normal_y;
	float normal_z;
	float tangent_x;
	float tangent_y;
	float tangent_z;
};

struct Skybox
{
	bool enabled;
	layout(bindless_sampler) samplerCube cubemap;
};

layout(std430, binding = 0) readonly buffer CameraBuffer
{
	Camera camera;
};

layout(std430, binding = 1) readonly buffer DirectionalLightBuffer
{
	DirectionalLight directionalLights[];
};

layout(std430, binding = 2) readonly buffer PointLightBuffer
{
	PointLight pointLights[];
};

layout(std430, binding = 3) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout(std430, binding = 4) readonly buffer PlaneBuffer
{
	Plane planes[];
};

layout(std430, binding = 5) readonly buffer MeshBuffer
{
	Mesh meshes[];
};

layout(std430, binding = 6) readonly buffer MeshVertexBuffer
{
	Vertex meshVertices[];
};

layout(std430, binding = 7) readonly buffer MeshIndexBuffer
{
	uint meshIndices[];
};

layout(std430, binding = 8) readonly buffer SkyboxBuffer
{
	Skybox skybox;
};

layout (bindless_image) writeonly uniform image2D o_renderImage;
layout (bindless_image) writeonly uniform iimage2D o_objectIndexImage;

bool between(float min, float max, float v);

vec3 localToWorldDirection(Transform transform, vec3 direction);
vec3 worldToLocalDirection(Transform transform, vec3 direction);
vec3 localToWorldPosition(Transform transform, vec3 position);
vec3 worldToLocalPosition(Transform transform, vec3 position);
Ray localToWorldRay(Transform transform, Ray ray);
Ray worldToLocalRay(Transform transform, Ray ray);
vec3 localToWorldNormal(Transform transform, vec3 normal);

//vec3 background(vec3 dir);
vec3 sampleSkybox(vec3 dir);

HitInfo trace(Ray ray);

void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo);
void intersectPlane(Ray ray, Plane plane, inout HitInfo hitInfo);
void intersectMesh(Ray ray, Mesh mesh, inout HitInfo hitInfo);

layout (local_size_x = 1, local_size_y = 1) in;
void main()
{
	vec2 normalizedPixelCoord = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy - 1);
	
	vec3 interpolatedTopRayDir = mix(camera.rayTL, camera.rayTR, normalizedPixelCoord.x);
	vec3 interpolatedBottomRayDir = mix(camera.rayBL, camera.rayBR, normalizedPixelCoord.x);
	
	vec3 interpolatedRayDir = mix(interpolatedBottomRayDir, interpolatedTopRayDir, normalizedPixelCoord.y);
	
	Ray ray = Ray(camera.position, normalize(interpolatedRayDir));
	
	HitInfo hitInfo = trace(ray);
	
	vec3 color;
	if (hitInfo.anyHit)
	{
		color = vec3(0);
		
		vec3 albedo = texture(hitInfo.material.albedo, hitInfo.uv).rgb;
		
		for (int i = 0; i < directionalLights.length(); i++)
		{
			DirectionalLight light = directionalLights[i];
			color += albedo * light.color * max(dot(hitInfo.normal, light.fragToLightDirection), 0);
		}
		
		for (int i = 0; i < pointLights.length(); i++)
		{
			PointLight light = pointLights[i];
			color += albedo * light.color * max(dot(hitInfo.normal, normalize(light.position - hitInfo.impact)), 0);
		}
	}
	else
	{
		color = sampleSkybox(ray.direction);
	}
	
	imageStore(o_renderImage, ivec2(gl_GlobalInvocationID), vec4(color, 1));
	imageStore(o_objectIndexImage, ivec2(gl_GlobalInvocationID), hitInfo.anyHit ? ivec4(hitInfo.objectIndex, 0, 0, 0) : ivec4(-1, 0, 0, 0));
}

vec3 localToWorldDirection(Transform transform, vec3 direction)
{
	return mat3(transform.localToWorldDirection) * direction;
}

vec3 worldToLocalDirection(Transform transform, vec3 direction)
{
	return mat3(transform.worldToLocalDirection) * direction;
}

vec3 localToWorldPosition(Transform transform, vec3 position)
{
	return (transform.localToWorld * vec4(position, 1)).xyz;
}

vec3 worldToLocalPosition(Transform transform, vec3 position)
{
	return (transform.worldToLocal * vec4(position, 1)).xyz;
}

Ray localToWorldRay(Transform transform, Ray ray)
{
	return Ray
	(
		localToWorldPosition(transform, ray.origin),
		normalize(localToWorldDirection(transform, ray.direction))
	);
}

Ray worldToLocalRay(Transform transform, Ray ray)
{
	return Ray
	(
		worldToLocalPosition(transform, ray.origin),
		normalize(worldToLocalDirection(transform, ray.direction))
	);
}

vec3 localToWorldNormal(Transform transform, vec3 normal)
{
	return (transform.localToWorldNormal * vec4(normal, 1)).xyz;
}

vec3 srgbToLinear(vec3 color)
{
	bvec3 cutoff = lessThan(color, vec3(0.04045));
	vec3 higher = pow((color + vec3(0.055))/vec3(1.055), vec3(2.4));
	vec3 lower = color/vec3(12.92);
	
	return mix(higher, lower, cutoff);
}

//vec3 background(vec3 dir)
//{
//	const vec3 sky = vec3(0.21763764, 0.45626346, 1.0);
//	const vec3 ground = vec3(1.0, 1.0, 1.0);
//
//	float t = dir.y * 0.5 + 0.5;
//	return srgbToLinear(mix(ground, sky, t));
//}

vec3 sampleSkybox(vec3 dir)
{
	return skybox.enabled ? texture(skybox.cubemap, dir * vec3(-1, -1, 1)).rgb : vec3(0);
}

HitInfo trace(Ray ray)
{
	HitInfo hitInfo;
	hitInfo.anyHit = false;
	
	for (int i = 0; i < spheres.length(); i++)
	{
		intersectSphere(ray, spheres[i], hitInfo);
	}
	
	for (int i = 0; i < planes.length(); i++)
	{
		intersectPlane(ray, planes[i], hitInfo);
	}
	
	for (int i = 0; i < meshes.length(); i++)
	{
		intersectMesh(ray, meshes[i], hitInfo);
	}
	
	return hitInfo;
}

bool between(float min, float max, float v)
{
	return v >= min && v <= max;
}

void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(sphere.transform, ray);
	
	vec3 origin = localRay.origin;
	vec3 direction = localRay.direction;
	
	float a = dot(direction, direction);
	float b = 2 * dot(direction, origin);
	float c = dot(origin, origin) - 1;
	
	float discriminant = b*b - 4*a*c;
	
	if (discriminant < 0)
	{
		return;
	}
	
	float t;
	
	if (discriminant == 0)
	{
		t = (-b)/(2*a);
	}
	else //if (discriminant > 0)
	{
		float t0 = (-b - sqrt(discriminant)) / (2*a);
		float t1 = (-b + sqrt(discriminant)) / (2*a);
		
		if (t0 > 0 && t0 < t1)
		{
			t = t0;
		}
		else //if (t1 > 0 && t1 < t0)
		{
			t = t1;
		}
	}
	
	if (t > 0)
	{
		vec3 localImpact = origin + direction * t;
		vec3 worldImpact = localToWorldPosition(sphere.transform, localImpact);
		t = distance(ray.origin, worldImpact); // fix t scaling
		
		if (!hitInfo.anyHit || t < hitInfo.t)
		{
			hitInfo.t = t;
			hitInfo.anyHit = true;
			hitInfo.impact = worldImpact;
			
			vec3 potentialNormal = normalize(localToWorldNormal(sphere.transform, localImpact));
			hitInfo.normal = dot(potentialNormal, -ray.direction) > 0 ? potentialNormal : -potentialNormal;
			
			hitInfo.material = sphere.material;
			
			float phi = atan(localImpact.z, localImpact.x);
			float theta = asin(localImpact.y);
			hitInfo.uv.x = 1 - (phi + PI) / (2 * PI);
			hitInfo.uv.y = (theta + PI / 2) / PI;
			
			hitInfo.objectIndex = sphere.objectIndex;
		}
	}
	
	return;
}

void intersectPlane(Ray ray, Plane plane, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(plane.transform, ray);
	
	vec3 origin = localRay.origin;
	vec3 direction = localRay.direction;
	
	float t = -(origin.y/direction.y);
	
	if (t > 0)
	{
		vec3 localImpact = origin + direction * t;
		
		if (!plane.infinite && (!between(-1, 1, localImpact.x) || !between(-1, 1, localImpact.z)))
		{
			return;
		}
		
		vec3 worldImpact = localToWorldPosition(plane.transform, localImpact);
		t = distance(ray.origin, worldImpact); // fix t scaling
		
		if (!hitInfo.anyHit || t < hitInfo.t)
		{
			hitInfo.t = t;
			hitInfo.anyHit = true;
			hitInfo.impact = localToWorldPosition(plane.transform, localImpact);
			
			vec3 potentialNormal = normalize(localToWorldNormal(plane.transform, vec3(0, 1, 0)));
			hitInfo.normal = dot(potentialNormal, -ray.direction) > 0 ? potentialNormal : -potentialNormal;
			
			hitInfo.material = plane.material;
			hitInfo.uv = vec2(localImpact.x, localImpact.z) * 0.5 + 0.5;
			
			hitInfo.objectIndex = plane.objectIndex;
		}
	}
}

void intersectMesh(Ray ray, Mesh mesh, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(mesh.transform, ray);
	
	vec3 origin = localRay.origin;
	vec3 direction = localRay.direction;
	
	for (int i = 0; i < mesh.indexCount; i += 3)
	{
		Vertex vertex0 = meshVertices[mesh.vertexOffset + meshIndices[mesh.indexOffset + i + 0]];
		Vertex vertex1 = meshVertices[mesh.vertexOffset + meshIndices[mesh.indexOffset + i + 1]];
		Vertex vertex2 = meshVertices[mesh.vertexOffset + meshIndices[mesh.indexOffset + i + 2]];
		
		vec3 v0 = vec3(vertex0.position_x, vertex0.position_y, vertex0.position_z);
		vec3 v1 = vec3(vertex1.position_x, vertex1.position_y, vertex1.position_z);
		vec3 v2 = vec3(vertex2.position_x, vertex2.position_y, vertex2.position_z);
		
		vec3 v0v1 = v1 - v0;
		vec3 v0v2 = v2 - v0;
		vec3 pvec = cross(direction, v0v2);
		float det = dot(v0v1, pvec);
		
		// if the determinant is negative the triangle is backfacing
		// ray and triangle are parallel if det is close to 0
		if (abs(det) == 0) continue;
		
		float invDet = 1 / det;
		
		vec3 tvec = origin - v0;
		float u = dot(tvec, pvec) * invDet;
		if (u < 0 || u > 1) continue;
		
		vec3 qvec = cross(tvec, v0v1);
		float v = dot(direction, qvec) * invDet;
		if (v < 0 || u + v > 1) continue;
		
		float t = dot(v0v2, qvec) * invDet;
		
		if (t > 0)
		{
			vec3 localImpact = origin + direction * t;
			vec3 worldImpact = localToWorldPosition(mesh.transform, localImpact);
			t = distance(ray.origin, worldImpact); // fix t scaling
			
			if (!hitInfo.anyHit || t < hitInfo.t)
			{
				hitInfo.t = t;
				hitInfo.anyHit = true;
				hitInfo.impact = localToWorldPosition(mesh.transform, localImpact);
				
				vec3 triangleNormal = normalize(cross(v0v1, v0v2));
				vec3 smoothNormal;
				if (dot(triangleNormal, -direction) >= 0)
				{
					smoothNormal = vec3(vertex0.normal_x, vertex0.normal_y, vertex0.normal_z) * (1 - u - v) +
								   vec3(vertex1.normal_x, vertex1.normal_y, vertex1.normal_z) * u +
								   vec3(vertex2.normal_x, vertex2.normal_y, vertex2.normal_z) * v;
				}
				else
				{
					smoothNormal = -vec3(vertex0.normal_x, vertex0.normal_y, vertex0.normal_z) * (1 - u - v) +
								   -vec3(vertex1.normal_x, vertex1.normal_y, vertex1.normal_z) * u +
								   -vec3(vertex2.normal_x, vertex2.normal_y, vertex2.normal_z) * v;
				}
				
				hitInfo.normal = normalize(localToWorldNormal(mesh.transform, normalize(smoothNormal)));
				
				hitInfo.material = mesh.material;
				
				hitInfo.uv = vec2(vertex0.u, vertex0.v) * (1 - u - v) +
							 vec2(vertex1.u, vertex1.v) * u +
							 vec2(vertex2.u, vertex2.v) * v;
				
				hitInfo.objectIndex = mesh.objectIndex;
			}
		}
	}
}

#version 460 core
#extension GL_ARB_bindless_texture : enable

/* ------ consts ------ */
const float PI = 3.14159265359;
const float TWO_PI = PI*2;
const float SQRT_2 = 1.41421356237;

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Camera
{
	vec3 position;
	float padding0;
	vec3 rayTL;
	float padding1;
	vec3 rayTR;
	float padding2;
	vec3 rayBL;
	float padding3;
	vec3 rayBR;
	float padding4;
};

struct Material
{
	layout(bindless_sampler) sampler2D albedo;
	layout(bindless_sampler) sampler2D normal;
	layout(bindless_sampler) sampler2D roughness;
	layout(bindless_sampler) sampler2D metallic;
	layout(bindless_sampler) sampler2D displacement;
	layout(bindless_sampler) sampler2D emissive;
};

struct HitInfo
{
	bool anyHit;
	float t;
	vec3 impact;
	vec3 normal;
	Material material;
	vec2 uv;
	int objectIndex;
};

struct Transform
{
	mat4 localToWorld;
	mat4 worldToLocal;
	mat4 localToWorldDirection;
	mat4 worldToLocalDirection;
	mat4 localToWorldNormal;
};

struct Sphere
{
	Material material;
	Transform transform;
	int objectIndex;
	float padding0;
	float padding1;
	float padding2;
};

struct Plane
{
	Material material;
	Transform transform;
	bool infinite;
	int objectIndex;
	float padding0;
	float padding1;
};

struct DirectionalLight
{
	vec3 fragToLightDirection;
	float angularDiameter;
	vec3 color;
	float intensity;
};

struct PointLight
{
	vec3 position;
	float size;
	vec3 color;
	float intensity;
};

layout(std430, binding = 0) readonly buffer CameraBuffer
{
	Camera camera;
};

layout(std430, binding = 1) readonly buffer DirectionalLightBuffer
{
	DirectionalLight directionalLights[];
};

layout(std430, binding = 2) readonly buffer PointLightBuffer
{
	PointLight pointLights[];
};

layout(std430, binding = 3) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout(std430, binding = 4) readonly buffer PlaneBuffer
{
	Plane planes[];
};

layout (bindless_image) writeonly uniform image2D o_renderImage;
layout (bindless_image) writeonly uniform iimage2D o_objectIndexImage;

bool between(float min, float max, float v);

vec3 localToWorldDirection(Transform transform, vec3 direction);
vec3 worldToLocalDirection(Transform transform, vec3 direction);
vec3 localToWorldPosition(Transform transform, vec3 position);
vec3 worldToLocalPosition(Transform transform, vec3 position);
Ray localToWorldRay(Transform transform, Ray ray);
Ray worldToLocalRay(Transform transform, Ray ray);
vec3 localToWorldNormal(Transform transform, vec3 normal);

vec3 background(vec3 dir);

HitInfo trace(Ray ray);

void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo);
void intersectPlane(Ray ray, Plane plane, inout HitInfo hitInfo);

layout (local_size_x = 1, local_size_y = 1) in;
void main()
{
	vec2 normalizedPixelCoord = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy - 1);
	
	vec3 interpolatedTopRayDir = mix(camera.rayTL, camera.rayTR, normalizedPixelCoord.x);
	vec3 interpolatedBottomRayDir = mix(camera.rayBL, camera.rayBR, normalizedPixelCoord.x);
	
	vec3 interpolatedRayDir = mix(interpolatedBottomRayDir, interpolatedTopRayDir, normalizedPixelCoord.y);
	
	Ray ray = Ray(camera.position, normalize(interpolatedRayDir));
	
	HitInfo hitInfo = trace(ray);
	
	vec3 color;
	if (hitInfo.anyHit)
	{
		color = vec3(0);
		
		vec3 albedo = texture(hitInfo.material.albedo, hitInfo.uv).rgb;
		
		for (int i = 0; i < directionalLights.length(); i++)
		{
			DirectionalLight light = directionalLights[i];
			color += albedo * light.color * max(dot(hitInfo.normal, light.fragToLightDirection), 0);
		}
		
		for (int i = 0; i < pointLights.length(); i++)
		{
			PointLight light = pointLights[i];
			color += albedo * light.color * max(dot(hitInfo.normal, normalize(light.position - hitInfo.impact)), 0);
		}
	}
	else
	{
		color = background(ray.direction);
	}
	
	imageStore(o_renderImage, ivec2(gl_GlobalInvocationID), vec4(color, 1));
	imageStore(o_objectIndexImage, ivec2(gl_GlobalInvocationID), hitInfo.anyHit ? ivec4(hitInfo.objectIndex, 0, 0, 0) : ivec4(-1, 0, 0, 0));
}

vec3 localToWorldDirection(Transform transform, vec3 direction)
{
	return mat3(transform.localToWorldDirection) * direction;
}

vec3 worldToLocalDirection(Transform transform, vec3 direction)
{
	return mat3(transform.worldToLocalDirection) * direction;
}

vec3 localToWorldPosition(Transform transform, vec3 position)
{
	return (transform.localToWorld * vec4(position, 1)).xyz;
}

vec3 worldToLocalPosition(Transform transform, vec3 position)
{
	return (transform.worldToLocal * vec4(position, 1)).xyz;
}

Ray localToWorldRay(Transform transform, Ray ray)
{
	return Ray
	(
		localToWorldPosition(transform, ray.origin),
		normalize(localToWorldDirection(transform, ray.direction))
	);
}

Ray worldToLocalRay(Transform transform, Ray ray)
{
	return Ray
	(
		worldToLocalPosition(transform, ray.origin),
		normalize(worldToLocalDirection(transform, ray.direction))
	);
}

vec3 localToWorldNormal(Transform transform, vec3 normal)
{
	return (transform.localToWorldNormal * vec4(normal, 1)).xyz;
}

vec3 srgbToLinear(vec3 color)
{
	bvec3 cutoff = lessThan(color, vec3(0.04045));
	vec3 higher = pow((color + vec3(0.055))/vec3(1.055), vec3(2.4));
	vec3 lower = color/vec3(12.92);
	
	return mix(higher, lower, cutoff);
}

vec3 background(vec3 dir)
{
	const vec3 sky = vec3(0.21763764, 0.45626346, 1.0);
	const vec3 ground = vec3(1.0, 1.0, 1.0);
	
	float t = dir.y * 0.5 + 0.5;
	return srgbToLinear(mix(ground, sky, t));
}

HitInfo trace(Ray ray)
{
	HitInfo hitInfo;
	hitInfo.anyHit = false;
	
	for (int i = 0; i < spheres.length(); i++)
	{
		intersectSphere(ray, spheres[i], hitInfo);
	}
	
	for (int i = 0; i < planes.length(); i++)
	{
		intersectPlane(ray, planes[i], hitInfo);
	}
	
	return hitInfo;
}

bool between(float min, float max, float v)
{
	return v >= min && v <= max;
}

void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(sphere.transform, ray);
	
	vec3 origin = localRay.origin;
	vec3 direction = localRay.direction;
	
	float a = dot(direction, direction);
	float b = 2 * dot(direction, origin);
	float c = dot(origin, origin) - 1;
	
	float discriminant = b*b - 4*a*c;
	
	if (discriminant < 0)
	{
		return;
	}
	
	float t;
	
	if (discriminant == 0)
	{
		t = (-b)/(2*a);
	}
	else //if (discriminant > 0)
	{
		float t0 = (-b - sqrt(discriminant)) / (2*a);
		float t1 = (-b + sqrt(discriminant)) / (2*a);
		
		if (t0 > 0 && t0 < t1)
		{
			t = t0;
		}
		else //if (t1 > 0 && t1 < t0)
		{
			t = t1;
		}
	}
	
	if (t > 0)
	{
		vec3 localImpact = origin + direction * t;
		vec3 worldImpact = localToWorldPosition(sphere.transform, localImpact);
		t = distance(ray.origin, worldImpact); // fix t scaling
		
		if (!hitInfo.anyHit || t < hitInfo.t)
		{
			hitInfo.t = t;
			hitInfo.anyHit = true;
			hitInfo.impact = worldImpact;
			
			vec3 potentialNormal = normalize(localToWorldNormal(sphere.transform, localImpact));
			hitInfo.normal = dot(potentialNormal, -ray.direction) > 0 ? potentialNormal : -potentialNormal;
			
			hitInfo.material = sphere.material;
			
			float phi = atan(localImpact.z, localImpact.x);
			float theta = asin(localImpact.y);
			hitInfo.uv.x = 1 - (phi + PI) / (2 * PI);
			hitInfo.uv.y = (theta + PI / 2) / PI;
			
			hitInfo.objectIndex = sphere.objectIndex;
		}
	}
	
	return;
}

void intersectPlane(Ray ray, Plane plane, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(plane.transform, ray);
	
	vec3 origin = localRay.origin;
	vec3 direction = localRay.direction;
	
	float t = -(origin.y/direction.y);
	
	if (t > 0)
	{
		vec3 localImpact = origin + direction * t;
		
		if (!plane.infinite && (!between(-1, 1, localImpact.x) || !between(-1, 1, localImpact.z)))
		{
			return;
		}
		
		vec3 worldImpact = localToWorldPosition(plane.transform, localImpact);
		t = distance(ray.origin, worldImpact); // fix t scaling
		
		if (!hitInfo.anyHit || t < hitInfo.t)
		{
			hitInfo.t = t;
			hitInfo.anyHit = true;
			hitInfo.impact = localToWorldPosition(plane.transform, localImpact);
			
			vec3 potentialNormal = normalize(localToWorldNormal(plane.transform, vec3(0, 1, 0)));
			hitInfo.normal = dot(potentialNormal, -ray.direction) > 0 ? potentialNormal : -potentialNormal;
			
			hitInfo.material = plane.material;
			hitInfo.uv = vec2(localImpact.x, localImpact.z) * 0.5 + 0.5;
			
			hitInfo.objectIndex = plane.objectIndex;
		}
	}
}

#version 460 core
#extension GL_ARB_bindless_texture : enable

struct Ray
{
	vec3 origin;
	vec3 direction;
};

struct Camera
{
	vec3 position;
	float padding0;
	vec3 rayTL;
	float padding1;
	vec3 rayTR;
	float padding2;
	vec3 rayBL;
	float padding3;
	vec3 rayBR;
	float padding4;
};

struct HitInfo
{
	bool anyHit;
	float t;
	vec3 impact;
	vec3 normal;
	vec3 color;
};

struct Transform
{
	mat4 localToWorld;
	mat4 worldToLocal;
	mat4 localToWorldDirection;
	mat4 worldToLocalDirection;
};

struct Sphere
{
	Transform transform;
	vec3 color;
	float padding0;
};

layout(std430, binding = 0) readonly buffer RayBuffer
{
	Camera camera;
};

layout(std430, binding = 1) readonly buffer SphereBuffer
{
	Sphere spheres[];
};

layout (bindless_image) writeonly uniform image2D o_image;

vec3 localToWorldDirection(Transform transform, vec3 direction);
vec3 worldToLocalDirection(Transform transform, vec3 direction);
vec3 localToWorldPosition(Transform transform, vec3 position);
vec3 worldToLocalPosition(Transform transform, vec3 position);
Ray localToWorldRay(Transform transform, Ray ray);
Ray worldToLocalRay(Transform transform, Ray ray);
vec3 background(vec3 dir);
HitInfo trace(Ray ray);
void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo);

layout (local_size_x = 1, local_size_y = 1) in;
void main()
{
	vec2 normalizedPixelCoord = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy - 1);
//	normalizedPixelCoord.x = gl_GlobalInvocationID.x / float(gl_NumWorkGroups.x-1);
//	normalizedPixelCoord.y = gl_GlobalInvocationID.y / float(gl_NumWorkGroups.y-1);
	
	vec3 interpolatedTopRayDir = mix(camera.rayTL, camera.rayTR, normalizedPixelCoord.x);
	vec3 interpolatedBottomRayDir = mix(camera.rayBL, camera.rayBR, normalizedPixelCoord.x);
	
	vec3 interpolatedRayDir = mix(interpolatedBottomRayDir, interpolatedTopRayDir, normalizedPixelCoord.y);
	
	Ray ray = Ray(camera.position, normalize(interpolatedRayDir));
	
	HitInfo hitInfo = trace(ray);
	
	vec3 color;
	if (hitInfo.anyHit)
	{
		color = hitInfo.color;
	}
	else
	{
		color = background(ray.direction);
	}
	
	imageStore(o_image, ivec2(gl_GlobalInvocationID), vec4(color, 1));
}

vec3 localToWorldDirection(Transform transform, vec3 direction)
{
	return mat3(transform.localToWorldDirection) * direction;
}

vec3 worldToLocalDirection(Transform transform, vec3 direction)
{
	return mat3(transform.worldToLocalDirection) * direction;
}

vec3 localToWorldPosition(Transform transform, vec3 position)
{
	return (transform.localToWorld * vec4(position, 1)).xyz;
}

vec3 worldToLocalPosition(Transform transform, vec3 position)
{
	return (transform.worldToLocal * vec4(position, 1)).xyz;
}

Ray localToWorldRay(Transform transform, Ray ray)
{
	return Ray
	(
		localToWorldPosition(transform, ray.origin),
		normalize(localToWorldDirection(transform, ray.direction))
	);
}

Ray worldToLocalRay(Transform transform, Ray ray)
{
	return Ray
	(
		worldToLocalPosition(transform, ray.origin),
		normalize(worldToLocalDirection(transform, ray.direction))
	);
}

vec3 srgbToLinear(vec3 color)
{
	bvec3 cutoff = lessThan(color, vec3(0.04045));
	vec3 higher = pow((color + vec3(0.055))/vec3(1.055), vec3(2.4));
	vec3 lower = color/vec3(12.92);
	
	return mix(higher, lower, cutoff);
}

vec3 background(vec3 dir)
{
	const vec3 sky = vec3(0.21763764, 0.45626346, 1.0);
	const vec3 ground = vec3(1.0, 1.0, 1.0);
	
	float t = dir.y * 0.5 + 0.5;
	return srgbToLinear(mix(ground, sky, t));
}

HitInfo trace(Ray ray)
{
	HitInfo hitInfo;
	hitInfo.anyHit = false;
	
	for (int i = 0; i < spheres.length(); i++)
	{
		intersectSphere(ray, spheres[i], hitInfo);
	}
	
	return hitInfo;
}

void intersectSphere(Ray ray, Sphere sphere, inout HitInfo hitInfo)
{
	Ray localRay = worldToLocalRay(sphere.transform, ray);
	
	vec3 o = localRay.origin;
	vec3 v = localRay.direction;
	
	float a =     (v.x*v.x + v.y*v.y + v.z*v.z)    ;
	float b = 2 * (o.x*v.x + o.y*v.y + o.z*v.z)    ;
	float c =     (o.x*o.x + o.y*o.y + o.z*o.z) - 1;
	
	float delta = b*b - 4*a*c;
	
	if (delta < 0)
	{
		return;
	}
	
	float t;
	
	if (delta == 0)
	{
		t = (-b)/(2*a);
	}
	else //if (delta > 0)
	{
		float t1 = (-b - sqrt(delta)) / (2*a);
		float t2 = (-b + sqrt(delta)) / (2*a);
		
		if (t1 > 0 && t1 < t2)
		{
			t = t1;
		}
		else //if (t2 > 0 && t2 < t1)
		{
			t = t2;
		}
	}
	
	
	if (t > 0 && (!hitInfo.anyHit || hitInfo.t > t))
	{
		vec3 localImpact = o + v * t;
		
		hitInfo.t = t;
		hitInfo.anyHit = true;
		hitInfo.impact = localToWorldPosition(sphere.transform, localImpact);
		hitInfo.normal = normalize(localToWorldDirection(sphere.transform, localImpact));
		hitInfo.color = sphere.color;
	}
	
	return;
}
